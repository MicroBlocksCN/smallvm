module main
author 'Roger Wagner'
version 1 1 
description ''
variables CharacterList CharacterNames last_state TPin KeyboardOn folder IRCode Servo1Angle Servo2Angle MicroSDInserted IRCodeList IRNameList KeyPosition VolLevel ToneFreqList ToneNameList UltraSonicPresent NeoPixelsOn NumberOfNeopixels PreviousPinTouched MenuNumber CharPosn MakerPortSpeakerOn MenuEnableOn 

  spec ' ' 'Initialize_MakerPort' 'MakerPort initialize'
  spec ' ' 'Initialize lists' 'Initialize lists'
  spec ' ' 'NeoPixel initialize' 'NeoPixel initialize'
  spec ' ' 'DoMenus' 'DoMenus'
  spec ' ' 'MenuAction1' 'MenuAction1'
  spec ' ' 'MenuAction2' 'MenuAction2'
  spec ' ' 'MenuAction3' 'MenuAction3'
  spec ' ' 'MenuAction4' 'MenuAction4'
  spec ' ' 'MenuAction5' 'MenuAction5'
  spec ' ' 'MenuAction6' 'MenuAction6'

to DoMenus {
  MenuNumber += 1
  if MakerPortSpeakerOn {
    digitalWriteOp 19 true
    makerport_beep 880 100
    if MicroSDInserted {
      digitalWriteOp 19 false
    }
  }
  if (MenuNumber == 1) {
    LCD1602_write 'Menu1' 1
    LCD1602_write '(press again)' 2
    MenuAction1
  }
  if (MenuNumber == 2) {
    LCD1602_write 'Menu2' 1
    LCD1602_write 'Ring Test' 2
    MenuAction2
  }
  if (MenuNumber == 3) {
    LCD1602_write 'Menu3' 1
    LCD1602_write 'Servo Test' 2
    MenuAction3
  }
  if (MenuNumber == 4) {
    LCD1602_write 'Menu4' 1
    LCD1602_write 'Mic Test' 2
    MenuAction4
  }
  if (MenuNumber == 5) {
    LCD1602_write 'Menu5' 1
    LCD1602_write 'Distance' 2
    MenuAction5
  }
  if (MenuNumber == 6) {
    LCD1602_write 'Menu6' 1
    LCD1602_write 'Piano' 2
    comment 'last menu item'
    MenuNumber = 0
  }
}

to 'Initialize lists' {
  CharacterNames = ('[data:makeList]' 'left' 'up' 'right' 'down' 'space' 'click' 'w' 'a' 's' 'd' 'f' 'g')
  CharacterList = ('[data:makeList]' 216 218 215 217 ' ' 'click' 'w' 'a' 's' 'd' 'f' 'g')
  IRCodeList = ('[data:makeList]' 22 25 13 12 24 94 8 28 90 82 66 74 68 67 70 21 64)
  IRNameList = ('[data:makeList]' 1 2 3 4 5 6 7 8 9 0 '*' '#' 'left' 'right' 'up' 'down' 'OK')
  comment 'https://pages.mtu.edu/~suits/notefreqs.html'
  ToneFreqList = ('[data:makeList]' 262 294 330 349 392 440 494 523 587 659 698 784 880 988 1047 1175 1319)
  ToneNameList = ('[data:makeList]' 'C4' 'D4' 'E4' 'F4' 'G4' 'A4' 'B4' 'C5' 'D5' 'E5' 'F5' 'G5' 'A5' 'B5' 'C6' 'D6' 'E6')
}

to Initialize_MakerPort {
  mp3_initialize 'MakerPort' 20 21
  MicroSDInserted = (makerport_mp3_hasCard)
  attachIR 18
  if (LCD1602_isConnected) {
    LCD1602_clear
    LCD1602_write ' Welcome to the' 1
    LCD1602_write '   MakerPort!' 2
    MenuEnableOn = (booleanConstant true)
  } else {
    MenuEnableOn = (booleanConstant false)
  }
  if MakerPortSpeakerOn {
    if MicroSDInserted {
      comment 'Set audio switch to MP3 player.'
      digitalWriteOp 19 false
      mp3_playTrack 3 99
    } else {
      comment 'Set audio switch to tones'
      digitalWriteOp 19 true
      comment 'C4'
      makerport_beep 262 250
      comment 'G4'
      makerport_beep 392 250
      comment 'F4'
      makerport_beep 349 250
    }
  }
}

to MenuAction1 {
  comment 'nothing more to do here...'
}

to MenuAction2 {
  for i 12 {
    CharPosn = ('[misc:rescale]' i 1 12 6 16)
    LCD1602_write_field '.' 1 CharPosn CharPosn
    'NeoPixel initialize'
    waitMillis 250
  }
  LCD1602_write_field '(next)' 2 11 16
}

to MenuAction3 {
  repeat 3 {
    setServoAngle 16 0
    setServoAngle 17 0
    waitMillis 100
    setServoAngle 16 90
    setServoAngle 17 90
    waitMillis 500
    setServoAngle 16 0
    setServoAngle 17 0
    waitMillis 250
  }
  stopServo 16
  stopServo 17
  LCD1602_write_field '(next)' 2 11 16
}

to MenuAction4 {
  comment 'loop for 10 seconds @ 1/8 sec per loop'
  for i (8 * 10) {
    CharPosn = ('[misc:rescale]' i 1 (8 * 10) 6 16)
    LCD1602_write_field '.' 1 CharPosn CharPosn
    VolLevel = (timeAveragedLevel 13 125)
    setServoAngle 16 ('[misc:rescale]' VolLevel 0 250 0 90)
    LCD1602_write_field ('[data:join]' 'Vol:' VolLevel) 2 10 16
  }
  LCD1602_write_field '(next)' 2 10 16
}

to MenuAction5 {
  comment 'loop for 10 seconds @ 1/4 sec per loop'
  for i (10 * 4) {
    CharPosn = ('[misc:rescale]' i 1 (10 * 4) 6 16)
    LCD1602_write_field '.' 1 CharPosn CharPosn
    LCD1602_write_field ('[data:join]' 'Distance:' ('distance (cm)' 14 15)) 2 1 16
    waitMillis 250
  }
  LCD1602_write_field '(next)' 2 11 16
}

to MenuAction6 {
}

to 'NeoPixel initialize' {
  comment 'P14 = Extra port'
  neoPixelAttach 24 14
  for i NumberOfNeopixels {
    setNeoPixelColor i (randomColor)
  }
}

script 543 50 {
to Initialize_MakerPort {}
}

script 968 54 {
whenCondition (ir_code_received)
local 'IRCodeRcvd' (ir_last_code)
digitalWriteOp 19 true
makerport_beep (IRCodeRcvd * 15) 100
LCD1602_write ('[data:join]' 'IR code:' IRCodeRcvd) 1
KeyPosition = ('[data:find]' IRCodeRcvd IRCodeList)
if MicroSDInserted {
  digitalWriteOp 19 false
}
if (KeyPosition == -1) {
  LCD1602_write ('[data:join]' KeyPosition ', not found') 2
} else {
  digitalWriteOp KeyPosition true
  LCD1602_write ('[data:join]' KeyPosition ',' (at KeyPosition IRNameList)) 2
}
waitMillis 1000
LCD1602_clear
LCD1602_write 'waiting...' 1
makerport_setAllLEDs false
}

script 50 63 {
whenStarted
'Initialize lists'
KeyboardOn = (booleanConstant true)
MakerPortSpeakerOn = (booleanConstant true)
MenuEnableOn = (booleanConstant true)
PreviousPinTouched = 0
MenuNumber = 0
folder = 1
comment 'Neopixels OR ultrasonic in Extra port'
if (('distance (cm)' 14 15) == 0) {
  NeoPixelsOn = (booleanConstant true)
} else {
  NeoPixelsOn = (booleanConstant false)
}
NumberOfNeopixels = 24
Initialize_MakerPort
waitMillis 3000
LCD1602_clear
LCD1602_write 'waiting...' 1
if NeoPixelsOn {
  'NeoPixel initialize'
}
if MicroSDInserted {
  LCD1602_write_field ('[data:join]' 'Folder:' folder) 2 8 16
}
}

script 52 717 {
to 'Initialize lists' {}
}

script 540 783 {
to 'NeoPixel initialize' {}
}

script 58 1183 {
whenCondition (touch_touch_event)
local 'pin' (touch_last_touched_pin)
if (pin != 11) {
  MenuNumber = 0
}
if (and MenuEnableOn (and (pin == 11) (PreviousPinTouched == 11))) {
  DoMenus
}
if (MenuNumber == 0) {
  digitalWriteOp pin true
  LCD1602_write_field ('[data:join]' 'Touch:' pin) 1 1 16
  LCD1602_write_field (at pin CharacterNames) 2 1 16
  comment 'KeyboardOn = true to output characters'
  if KeyboardOn {
    if (pin == 6) {
      'mouse click' 'left'
    } else {
      '[hid:holdKey]' (at pin CharacterList)
    }
  }
  if MakerPortSpeakerOn {
    if (not MicroSDInserted) {
      makerport_beep (at pin ToneFreqList) 100
    } else {
      if (pin != 12) {mp3_playTrack pin folder}
    }
    if (and (pin == 12) MicroSDInserted) {
      folder += 1
      if (folder > 4) {
        folder = 1
        MakerPortSpeakerOn = (booleanConstant true)
      }
      if (folder == 4) {
        MakerPortSpeakerOn = (booleanConstant false)
      }
      LCD1602_write_field ('[data:join]' 'Folder:' folder) 2 8 16
      mp3_playTrack 99 folder
    }
    PreviousPinTouched = pin
  }
}
}

script 548 1185 {
whenCondition (touch_release_event)
local 'pin' (touch_last_released_pin)
if KeyboardOn {
  if (pin == 6) {
    '[hid:mouseRelease]'
  } else {
    '[hid:releaseKey]' (at pin CharacterList)
  }
}
if (MenuNumber == 0) {
  comment 'delay to keep LED on for a while'
  waitMillis 1000
  digitalWriteOp pin false
  LCD1602_clear
  LCD1602_write 'waiting...' 1
}
}

script 396 2163 {
to MenuAction1 {}
}

script 402 2338 {
to MenuAction2 {}
}

script 56 2481 {
to DoMenus {}
}

script 400 2585 {
to MenuAction3 {}
}

script 399 2961 {
to MenuAction4 {}
}

script 399 3317 {
to MenuAction5 {}
}


module 'Distance (HC-SR04)' Input
author 'Joan Guillén & Josep Ferràndiz'
version 1 2 
tags sensor 'hc-sr04' distance ultrasound 
description 'Support for the HC-SR04 ultrasound distance sensor.'
variables _sr04_last 

  spec 'r' 'distance (cm)' 'distance (cm) trigger _ echo _' 'num num' 2 4
  spec 'r' 'sr04_distanceOnePin' 'distance (cm) pin _' 'num' 0

to 'distance (cm)' trig ech {
  comment 'Contributed by Joan Guillén and Josep Ferràndiz'
  digitalWriteOp trig false
  waitMicros 2
  digitalWriteOp trig true
  waitMicros 50
  digitalWriteOp trig false
  local 'start' (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  waitUntil (or (digitalReadOp ech) (((microsOp) - start) > 23320))
  if (((microsOp) - start) > 23320) {
    comment 'Distance sensor not ready; return the last distance reading'
    return _sr04_last
  }
  comment 'Pulse sent. Measure time until echo is detected.'
  start = (microsOp)
  waitUntil (or (not (digitalReadOp ech)) (((microsOp) - start) > 23320))
  _sr04_last = ((10 * ((microsOp) - start)) / 583)
  comment 'Leave some time for reverberations to die away.'
  waitMillis 10
  if (_sr04_last == 0) {
    zeroCount += 1
  }
  return _sr04_last
}

to sr04_distanceOnePin pin {
  return ('distance (cm)' pin pin)
}


module 'IR Remote' Comm
author MicroBlocks
version 1 5 
tags ir infrared remote 
description 'Sends and receives infrared remote control messages like the ones used for TV sets or air conditioners. Currently supports only the NEC protocol, which is quite common but not the only IR protocol in use. An NEC message consists of a one byte device number and a one byte command.

Note: Transmitting IR does not work on ESP8266 boards.

Receiving requires an IR receiver module, such as those built into the Circuit Playground Express and ED1 boards. Transmitting requires an IR transmitter LED, such as those built into the Circuit Playground Express and several M5 Stack products. Inexpensive IR LED transmitter and receivers are available for use with other boards.'
variables _ir_pin _ir_pulse_times _ir_last_code _ir_last_device _ir_transmit_pin 

  spec ' ' 'attachIR' 'attach IR receiver to pin _' 'num' 0
  spec 'r' 'ir_code_received' 'IR code received?'
  spec 'r' 'ir_last_code' 'IR code'
  space
  spec ' ' 'IR_Transmit' 'IR transmit device _ command _' 'num num' 48896 1
  spec ' ' 'attachIRTransmitter' 'attach IR transmitter to pin _' 'num' 0
  space
  spec 'r' 'receiveIR' 'receive IR code'
  space
  spec ' ' '_testIR' '_test IR'
  spec 'r' '_receiveIRFromDevice' '_receive IR code from device _' 'num' 48896
  space
  spec ' ' '_captureIRMessage' '_captureIRMessage' 'any'
  spec ' ' '_dumpIR' '_dumpIR' 'any'
  spec 'r' '_getIRByte' '_getIRByte _' 'auto any' 4
  spec 'r' '_got32Bits' '_got32Bits' 'any'
  spec ' ' '_IR_SendByte' '_IR_SendByte _' 'auto' '10'

to IR_Transmit device command {
  if (_ir_transmit_pin == 0) {if (or ((boardType) == 'CircuitPlayground') ((boardType) == 'M5Atom-Matrix')) {
    _ir_transmit_pin = 12
  } (or ((boardType) == 'M5StickC') ((boardType) == 'M5StickC+')) {
    _ir_transmit_pin = 9
  }}
  comment 'Message start pulse and space'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 9000
  '[io:playTone]' _ir_transmit_pin 0
  waitMicros 4500
  comment 'Send device and command and their inverses'
  '_IR_SendByte' (device & 255)
  '_IR_SendByte' ((device >> 8) & 255)
  '_IR_SendByte' command
  '_IR_SendByte' ('~' command)
  comment 'Send stop bit'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 562
  '[io:playTone]' _ir_transmit_pin 0
  comment 'Turn off IR transmit LED'
  if (or ((boardType) == 'M5StickC') ((boardType) == 'M5StickC+')) {
    comment 'IR pin is inverted so true means "off"'
    digitalWriteOp _ir_transmit_pin true
  } else {
    digitalWriteOp _ir_transmit_pin false
  }
}

to '_IR_SendByte' byte {
  local 'bit' 1
  repeat 8 {
    if (0 == (byte & bit)) {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 530
    } else {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 1630
    }
    bit = (bit << 1)
  }
}

to '_captureIRMessage' {
  if (_ir_pulse_times == 0) {
    _ir_pulse_times = (newList 200)
    if (_ir_pin == 0) {
      if ((boardType) == 'CircuitPlayground') {
        _ir_pin = 11
      } ((boardType) == 'Citilab ED1') {
        _ir_pin = 35
      } ((boardType) == 'D1-Mini') {
        _ir_pin = 2
      } ((boardType) == 'MakerPort') {
        _ir_pin = 18
      }
    }
  }
  fillList _ir_pulse_times 0
  local 'i' 1
  comment 'Wait for IR signal -- this is the start of a new message.
Note: THe pin goes low when an IR signal is detected.'
  waitUntil (not (digitalReadOp _ir_pin))
  local 'start' (microsOp)
  forever {
    comment 'Record the time until the end of the current IR pulse ("mark")'
    waitUntil (digitalReadOp _ir_pin)
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
    comment 'Record time until the start of the next IR pulse ("space")'
    repeatUntil (not (digitalReadOp _ir_pin)) {
      if (((microsOp) - start) > 5000) {
        comment 'No IR pulse for 5000 usecs means "end of message"'
        return 0
      }
    }
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
  }
}

to '_dumpIR' {
  comment 'Print raw pulse timings to the terminal.
Can be used to analyze new protocols.'
  local 'i' 1
  printIt '-----'
  repeat (size _ir_pulse_times) {
    local 'mark usecs' (at i _ir_pulse_times)
    local 'space usecs' (at (i + 1) _ir_pulse_times)
    printIt (v 'mark usecs') (v 'space usecs')
    i += 2
    if ((v 'space usecs') == 0) {
      printIt 'timing entries:' (i - 2)
      return 0
    }
  }
}

to '_getIRByte' position {
  local 'result' 0
  local 'i' position
  local 'bit' 1
  repeat 8 {
    if ((at i _ir_pulse_times) > 1000) {result = (result | bit)}
    bit = (bit << 1)
    i += 2
  }
  return result
}

to '_got32Bits' {
  return (and ((at 67 _ir_pulse_times) != 0) ((at 68 _ir_pulse_times) == 0))
}

to '_receiveIRFromDevice' deviceID {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      local 'id_lowByte' ('_getIRByte' 4 nil)
      local 'id_highByte' ('_getIRByte' 20 nil)
      if (and (id_highByte == (deviceID >> 8)) (id_lowByte == (deviceID & 255))) {
        return ('_getIRByte' 36 nil)
      }
    }
  }
}

to '_testIR' {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      comment 'Four byte message format:
<device low byte><device high byte><command><command, bit-inverted>'
      local 'b1' ('_getIRByte' 4 nil)
      local 'b2' ('_getIRByte' 20 nil)
      local 'b3' ('_getIRByte' 36 nil)
      local 'b4' ('_getIRByte' 52 nil)
      sayIt 'Device:' ((b2 << 8) | b1) 'code:' b3
    }
  }
}

to attachIR pin {
  _ir_pin = pin
}

to attachIRTransmitter pin {
  _ir_transmit_pin = pin
}

to ir_code_received {
  return ((receiveIR) >= 0)
}

to ir_last_code {
  return _ir_last_code
}

to receiveIR {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      local 'id_lowByte' ('_getIRByte' 4 nil)
      local 'id_highByte' ('_getIRByte' 20 nil)
      _ir_last_device = ((id_highByte << 8) | id_lowByte)
      _ir_last_code = ('_getIRByte' 36 nil)
      atPut 'all' _ir_pulse_times 0
      return _ir_last_code
    }
  }
}


module 'Keyboard and Mouse' Comm
author MicroBlocks
version 1 3 
choices keyModifiers Shift Control 'Alt / ⌥' 'Logo / ⌘' AltGr 
choices mouseButtons left right middle both 
choices specialKeys 'enter:10' 'tab:179' 'backspace:178' 'delete:212' 'insert:209' 'home:210' 'end:213' 'PgUp:211' 'PgDown:214' '→:215' '←:216' '↓:217' '↑:218' 'F1:194' 'F2:195' 'F3:196' 'F4:197' 'F5:198' 'F6:199' 'F7:200' 'F8:201' 'F9:202' 'F10:203' 'F11:204' 'F12:205' 'CapsLock:193' 'NumLock:219' 'ScrollLock:207' 'PrintScreen:206' 'ESC:177' 
description 'HID library. Emulates mouse and keyboard actions.

It supports the Adafruit boards Trinket M0 and Metro M0 Express.'

  spec ' ' 'press key' 'press key _ : while holding _' 'auto menu.keyModifiers' 'n' 'Shift'
  spec ' ' '[hid:holdKey]' 'hold key _' 'auto' 'A'
  spec ' ' '[hid:releaseKey]' 'release key _' 'auto' 'A'
  spec ' ' '[hid:releaseKeys]' 'release all keys'
  space
  spec ' ' 'mouse click' '_ mouse click' 'menu.mouseButtons' 'left'
  spec ' ' '[hid:mouseMove]' 'move mouse pointer by _ , _' 'num num' 10 -20
  spec ' ' '[hid:mouseScroll]' 'scroll mouse by _' 'num' -5
  spec ' ' 'mouse hold' 'hold _ mouse button' 'menu.mouseButtons' 'left'
  spec ' ' '[hid:mouseRelease]' 'release mouse buttons'

to 'mouse click' which {
  '[hid:mousePress]' ('[data:find]' which ('[data:makeList]' 'left' 'right' 'both' 'middle'))
  waitMillis 50
  '[hid:mouseRelease]'
}

to 'mouse hold' which {
  '[hid:mousePress]' ('[data:find]' which ('[data:makeList]' 'left' 'right' 'both' 'middle'))
}

to 'press key' key modifier {
  '[hid:pressKey]' key ('[data:find]' modifier ('[data:makeList]' 'Shift' 'Control' 'Alt / ⌥' 'Logo / ⌘' 'AltGr'))
}


module 'LCD Display' Output
author MicroBlocks
version 1 5 
description 'Library for 16x2 LCD text displays with 1602 controller I2C "backpack" like the ones from DFRobot, SunFounder, and others. These displays have two lines of sixteen characters.

Most of these displays require 5 volts to provide sufficient LCD contrast, so you will need an external power source for 3.3v boards like the micro:bit.'
variables _LCD1602_ADDR _LCD1602_LINE1 _LCD1602_LINE2 _LCD1602_LOCK_MSECS 

  spec ' ' 'LCD1602_write' 'write _ on LCD line _' 'str num num num' 'Hello, World!' 1 1 16
  spec ' ' 'LCD1602_write_field' 'write field _ on LCD line _ from _ to _' 'str num num num' 'Moon!' 1 8 12
  spec ' ' 'LCD1602_clear' 'clear LCD'
  spec 'r' 'LCD1602_isConnected' 'is LCD connected?'
  spec 'r' '_LCD1602 init' '_LCD1602 init'
  spec ' ' '_LCD1602 send' '_LCD1602 send byte _ mode _' 'num num' 10 1
  spec ' ' '_LCD1602 toggle enable' '_LCD1602 toggle enable _' 'num' 10

to LCD1602_clear {
  if (not ('_LCD1602 init')) {return}
  waitUntil (((millisOp) - _LCD1602_LOCK_MSECS) > 500)
  _LCD1602_LOCK_MSECS = (millisOp)
  _LCD1602_LINE1 = ('[data:newByteArray]' 16 32)
  _LCD1602_LINE2 = ('[data:newByteArray]' 16 32)
  '_LCD1602 send' 1 0
  _LCD1602_LOCK_MSECS = 0
}

to LCD1602_isConnected {
  return ('_LCD1602 init')
}

to LCD1602_write string line {
  LCD1602_write_field string line 1 16
}

to LCD1602_write_buffer line {
  local 'bytes' 0
  if (line == 1) {
    '_LCD1602 send' (hexToInt '80') 0
    bytes = _LCD1602_LINE1
  } else {
    '_LCD1602 send' (hexToInt 'C0') 0
    bytes = _LCD1602_LINE2
  }
  for b bytes {
    '_LCD1602 send' b 1
  }
}

to LCD1602_write_field string line start end {
  if (not ('_LCD1602 init')) {return}
  string = ('[data:join]' '' string)
  if (or (start < 1) (start > 16)) {
    return
  }
  if (or (end < start) (end > 16)) {
    return
  }
  if (line == 1) {
    bytes = _LCD1602_LINE1
  } else {
    bytes = _LCD1602_LINE2
  }
  waitUntil (((millisOp) - _LCD1602_LOCK_MSECS) > 500)
  _LCD1602_LOCK_MSECS = (millisOp)
  local 'count' ((end - start) + 1)
  for i count {
    local 'char' 32
    if (i <= (size string)) {
      char = ('[data:unicodeAt]' i string)
      if (char > 127) {
        char = 32
      }
    }
    atPut ((start - 1) + i) bytes char
  }
  LCD1602_write_buffer line
  _LCD1602_LOCK_MSECS = 0
}

to '_LCD1602 init' {
  comment 'Return true if already initialized'
  if (_LCD1602_ADDR != 0) {
    return true
  }
  comment 'Use slow I2C speed'
  '[sensors:i2cSetClockSpeed]' 100000
  comment 'Try two common I2C addresses and
use the one that gets a response'
  _LCD1602_ADDR = (hexToInt '27')
  if ((i2cGet _LCD1602_ADDR 0) < 0) {
    _LCD1602_ADDR = (hexToInt '3F')
  }
  if ((i2cGet _LCD1602_ADDR 0) < 0) {
    _LCD1602_ADDR = 0
    comment 'LCD panel not found'
    return false
  }
  _LCD1602_LINE1 = ('[data:newByteArray]' 16 32)
  _LCD1602_LINE2 = ('[data:newByteArray]' 16 32)
  comment 'Initialize display'
  '_LCD1602 send' (hexToInt '33') 0
  '_LCD1602 send' (hexToInt '32') 0
  '_LCD1602 send' (hexToInt '06') 0
  '_LCD1602 send' (hexToInt '0C') 0
  '_LCD1602 send' (hexToInt '28') 0
  '_LCD1602 send' (hexToInt '01') 0
  '[sensors:i2cSetClockSpeed]' 400000
  waitMillis 250
  return true
}

to '_LCD1602 send' bits mode {
  comment 'Use slow I2C speed'
  '[sensors:i2cSetClockSpeed]' 100000
  local '_LCD1602 BACKLIGHT' (hexToInt '8')
  local 'high bits' ((mode | (bits & (hexToInt 'F0'))) | (v '_LCD1602 BACKLIGHT'))
  local 'low bits' ((mode | ((bits << 4) & (hexToInt 'F0'))) | (v '_LCD1602 BACKLIGHT'))
  '[sensors:i2cWrite]' _LCD1602_ADDR (v 'high bits')
  '_LCD1602 toggle enable' (v 'high bits')
  '[sensors:i2cWrite]' _LCD1602_ADDR (v 'low bits')
  '_LCD1602 toggle enable' (v 'low bits')
  comment 'Revert to fast I2C speed'
  '[sensors:i2cSetClockSpeed]' 400000
  waitMillis 1
}

to '_LCD1602 toggle enable' bits {
  local '_LCD1602 ENABLE' 4
  waitMicros 5
  '[sensors:i2cWrite]' _LCD1602_ADDR (bits | (v '_LCD1602 ENABLE'))
  waitMicros 5
  '[sensors:i2cWrite]' _LCD1602_ADDR (bits & ('~' (v '_LCD1602 ENABLE')))
  waitMicros 5
}


module 'MP3 Player' Output
author MicroBlocks
version 1 8 
choices mp3PlayerType MakerPort 'MakerBit/HyperDuino' DFRobot Octopus 
description 'Support for Octopus (FN-M16P and YX6300 chips) and DFRobot/HyperDuino/MakerBit) MP3 Players (YX5300, A19HFA440, and GD3300B chips).

Sends commands to MP3 player using software serial via any digital pin on any board.

To use the "mp3 play ... until done" block, connect TX of MP3 player to a second pin and set that pin as the optional "rx pin" in the "mp3 initialize" block .
'
variables _mp3UseChecksum _mp3Pin _mp3RxPin 

  spec ' ' 'mp3_initialize' 'mp3 initialize _ pin _ : rx pin _' 'menu.mp3PlayerType num num' 'MakerPort' 20 21
  spec ' ' 'mp3_setVolume' 'mp3 set volume _ (0-30)' 'num' 20
  space
  spec ' ' 'mp3_playTrack' 'mp3 play track _ in folder _' 'num num' 1 1
  spec ' ' 'mp3_playTrackUntilDone' 'mp3 play track _ in folder _ until done' 'num num' 1 1
  space
  spec ' ' 'mp3_nextTrack' 'mp3 play next track'
  spec ' ' 'mp3_repeatAllInFolder' 'mp3 repeat all in folder _' 'num' 1
  space
  spec ' ' 'mp3_pause' 'mp3 pause'
  spec ' ' 'mp3_resume' 'mp3 resume'
  space
  spec ' ' '_mp3_sendMP3Cmd' '_mp3_sendMP3Cmd _ _ _' 'auto num num' '0x0C' 0 0
  spec ' ' '_mp3_waitForResponse' '_mp3_waitForResponse'

to '_mp3_sendMP3Cmd' cmd arg1 arg2 {
  if (_mp3UseChecksum == 0) {
    sayIt 'MP3 Player is not initialized'
    return 0
  }
  if _mp3UseChecksum {
    comment 'Include checksum (10 bytes total)'
    local 'msg' ('[data:makeList]' (hexToInt '7E') (hexToInt 'FF') 6 (hexToInt cmd) 0 arg1 arg2 0 0 (hexToInt 'EF'))
    local 'sum' 0
    for i 6 {
      sum += (at (i + 1) msg)
    }
    sum = (65536 - sum)
    atPut 8 msg ((sum >> 8) & 255)
    atPut 9 msg (sum & 255)
  } else {
    comment 'No checksum (8 bytes total)'
    local 'msg' ('[data:makeList]' (hexToInt '7E') (hexToInt 'FF') 6 (hexToInt cmd) 0 arg1 arg2 (hexToInt 'EF'))
  }
  comment 'Send the command'
  for byte msg {
    '[io:softWriteByte]' byte _mp3Pin 9600
  }
  waitMillis 100
}

to '_mp3_waitForResponse' {
  comment 'Wait for a response on _mp3RxPin.
Note: a low value on _mp3RxPin is the start of a response message.
We do not read the actual message but wait 20 bytes worth of time.'
  if (_mp3RxPin >= 0) {
    local 'endTime' ((millisOp) + 3000)
    repeatUntil (not (digitalReadOp _mp3RxPin)) {
      if ((millisOp) > endTime) {return 0}
    }
    waitMillis 21
  } else {
    comment 'RX pin not set so just wait a few seconds.'
    waitMillis 3000
  }
}

to mp3_initialize type pin optionalRxPin {
  _mp3UseChecksum = ('Octopus' != type)
  _mp3Pin = pin
  _mp3RxPin = -1
  if ((pushArgCount) > 2) {
    _mp3RxPin = optionalRxPin
  }
  comment 'Reset'
  '_mp3_sendMP3Cmd' '0x0C' 0 0
  if (_mp3RxPin >= 0) {
    '_mp3_waitForResponse'
  } else {
    waitMillis 1000
  }
}

to mp3_nextTrack {
  comment 'Skip to the next track in the current folder, wrapping back to the first track.'
  mp3_pause
  comment 'Disable folder repeat'
  '_mp3_sendMP3Cmd' '0x08' 0 0
  waitMillis 50
  '_mp3_sendMP3Cmd' '0x01' 0 0
}

to mp3_pause {
  '_mp3_sendMP3Cmd' '0x0E' 0 0
}

to mp3_playTrack trackNum folderNum {
  comment 'Play the given track in the given folder.
If folder is 0, play the given track at the top level of the SD card.
Folder names must start with two digits, 01-99.
Track names in a folder must start with three digits, 001-999.
Track names at the top level must start with four digits, 0001-9999.
This sets the folder for the "play next track in folder" command.'
  if (folderNum < 1) {
    comment 'Play top-level track (e.g. 0001)'
    '_mp3_sendMP3Cmd' '0x03' 0 trackNum
  } else {
    comment 'Play track in folder'
    '_mp3_sendMP3Cmd' '0x0F' folderNum trackNum
    comment 'Hack: Send command twice to increase reliability on MakerPort v1.00'
    '_mp3_sendMP3Cmd' '0x0F' folderNum trackNum
  }
}

to mp3_playTrackUntilDone trackNum folderNum {
  if (_mp3RxPin < 0) {sayIt 'To use this feature, set the RX pin in "mp3 initialize".'}
  mp3_playTrack trackNum folderNum
  '_mp3_waitForResponse'
}

to mp3_repeatAllInFolder folderNum {
  comment 'Repeatedly play all files in the given folder. Does not work for top level (folder 0).'
  '_mp3_sendMP3Cmd' '0x17' folderNum folderNum
  mp3_resume
}

to mp3_resume {
  '_mp3_sendMP3Cmd' '0x0D' 0 0
}

to mp3_setVolume level {
  comment 'Range is 0-30'
  '_mp3_sendMP3Cmd' '0x06' 0 level
}


module MakerPort Output
author MicroBlocks
version 1 5 
depends 'LCD Display' 'MP3 Player' 'Touch (MPR121)' 
choices makerport_audioSource MP3 Tone 
description 'Support for MakerPort (https://makerport.fun)'

  spec ' ' 'makerport_initialize' 'MakerPort initialize'
  space
  spec ' ' 'makerport_beep' 'MakerPort tone _ Hz for _ msecs' 'num num' 440 100
  spec ' ' 'makerport_setAudioSource' 'set MakerPort audio source to _' 'menu.makerport_audioSource' 'MP3'
  space
  spec ' ' 'makerport_setAllLEDs' 'set all MakerPort LEDs _' 'bool' false
  space
  spec ' ' 'makerport_typeString' 'type _ to computer' 'str' 'Hello from MakerPort!'
  space
  spec 'r' 'makerport_mp3_hasCard' 'mp3 player has Flash card'

to makerport_beep freq msecs {
  digitalWriteOp 19 true
  '[io:playTone]' 0 freq
  waitMillis msecs
  '[io:playTone]' 0 0
}

to makerport_initialize {
  attachIR 18
  mp3_initialize 'MakerPort' 20 21
  makerport_setAudioSource 'MP3'
}

to makerport_mp3_hasCard {
  comment 'Note: This command works only if MP3 player is
connected to the hardware serial pins.'
  '[serial:open]' 9600
  comment 'Send MP3 player initialization command'
  '[serial:write]' ('[data:makeList]' (hexToInt '7E') (hexToInt 'FF') 6 (hexToInt '0C') 0 0 0 254 239 (hexToInt 'EF'))
  local 'bytesRead' ('[data:newByteArray]' 0)
  repeat 60 {
    comment 'Loop for up to 3 seconds while waiting for a response'
    bytesRead = ('[data:join]' bytesRead ('[serial:read]'))
    if ((size bytesRead) >= 10) {
      comment 'Got a response message. Item 7 is 2 if
a Flash card is inserted in the player.'
      '[serial:close]'
      return ((at 7 bytesRead) == 2)
    }
    waitMillis 50
  }
  '[serial:close]'
  return (booleanConstant false)
}

to makerport_setAllLEDs bool {
  for pin 12 {
    digitalWriteOp pin bool
  }
}

to makerport_setAudioSource src {
  digitalWriteOp 19 (src != 'MP3')
}

to makerport_typeString s {
  for ch s {
    '[hid:pressKey]' ch -1
  }
}


module MultiTone Output
author MicroBlocks
version 1 1 
description 'On boards that support it, play up to four simultaneous voices of music through a single speaker. The best sound quality is obtained by playing through through an amplified external speaker, but you can hear it through the built-in speakers on the micro:bit V2, Circuit Playground Express and Bluefruit, and M5 Stack/Core.

Note: This library does NOT work on the original micro:bit or Calliope mini!

To output the audio waveform, the board must have a DAC (e.g. SAMD21 and ESP32 boards) or fast enough pulse-width modulation (PWM) hardware to simulate a DAC (e.g. nRF52 boards). To tune the output to standard A=440 pitch on boards with different clock speeds, change the tuningConstant variable in _stepForNote.'
variables _multiTonePin _multiToneInitialized _v1 _v2 _v3 _v4 _v1Step _v2Step _v3Step _v4Step 

  spec ' ' 'playNoteOnVoice' 'play note _ octave _ for _ ms voice _' 'auto num num num' 'A' 0 500 1
  spec ' ' 'setMultitonePin' 'set multitone pin _' 'auto' ''
  spec 'r' '_baseFreqForNoteMulti' '_baseFreqForNoteMulti _' 'auto' 'A'
  spec ' ' '_initMultiTone' '_initMultiTone'
  spec ' ' '_multiToneLoop' '_multiToneLoop'
  spec 'r' '_nextSample' '_nextSample'
  spec 'r' '_stepForNote' '_stepForNote _ octave _' 'str num' 'A' 0
  spec 'r' '_uppercaseNote' '_uppercaseNote _' 'auto' ' a '

to '_baseFreqForNoteMulti' note {
  comment 'Return the frequency for the given note in the middle-C octave
scaled by 1000. For example, return 440000 (440Hz) for A.
Note names may be upper or lower case and may be followed
by # for a sharp or _ for a flat.'
  note = ('_uppercaseNote' note)
  if (note == 'C') {
    return 261626
  } (note == 'D') {
    return 293665
  } (note == 'E') {
    return 329628
  } (note == 'F') {
    return 349228
  } (note == 'G') {
    return 391995
  } (note == 'A') {
    return 440000
  } (note == 'B') {
    return 493883
  }
  if (or (note == 'C#') (note == 'D_')) {
    return 277183
  } (or (note == 'D#') (note == 'E_')) {
    return 311127
  } (or (note == 'F#') (note == 'G_')) {
    return 369994
  } (or (note == 'G#') (note == 'A_')) {
    return 415305
  } (or (note == 'A#') (note == 'B_')) {
    return 466164
  }
  comment 'Unrecognized note names map to 0.1 Hz, which is inaudible.
This helps users find typos in their tunes.'
  return 100
}

to '_initMultiTone' {
  if ((boardType) == 'micro:bit v2') {
    _multiTonePin = 27
  } ((boardType) == 'Clue') {
    _multiTonePin = 21
  } (or ((boardType) == 'Citilab ED1') ((boardType) == 'M5StickC')) {
    _multiTonePin = 26
  } ((boardType) == 'M5Stack-Core') {
    _multiTonePin = 25
  } else {
    _multiTonePin = 0
  }
  _multiToneInitialized = true
}

to '_multiToneLoop' {
  if (not _multiToneInitialized) {'_initMultiTone'}
  comment 'Set initial sample values to virtual zero (the middle of their range).'
  _v1 = 65536
  _v2 = 65536
  _v3 = 65536
  _v4 = 65536
  comment 'Generate and output sound samples. The DAC on the ESP32
is only 8-bits. Other boards have 10-bit DAC or PWM output.'
  if (or ((boardType) == 'Citilab ED1') ((boardType) == 'M5Stack-Core')) {
    forever {
      analogWriteOp _multiTonePin ((('_nextSample') >> 3) + 128)
    }
  } else {
    forever {
      analogWriteOp _multiTonePin (('_nextSample') + 512)
    }
  }
}

to '_nextSample' {
  comment 'Generate up to four triangle waves. v1-v4 hold the current state of
each voice. These numbers range from 0-262143 and are increased by _v1Step-v4Step
each time this function is called. When the state rises above 131072, the output
value begins to decreases back to zero, so the output value for each voice ranges
from 0-131072 with the middle (65536) being "zero". This code has been optimized
to all four voices to be generated fast enough to play in real time on micro:bit v2.'
  _v1 = ((_v1 + _v1Step) & 262143)
  _v2 = ((_v2 + _v2Step) & 262143)
  _v3 = ((_v3 + _v3Step) & 262143)
  _v4 = ((_v4 + _v4Step) & 262143)
  local 'out' 0
  if (_v1 < 131072) {
    out += (_v1 - 65536)
  } else {
    out += (196608 - _v1)
  }
  if (_v2 < 131072) {
    out += (_v2 - 65536)
  } else {
    out += (196608 - _v2)
  }
  if (_v3 < 131072) {
    out += (_v3 - 65536)
  } else {
    out += (196608 - _v3)
  }
  if (_v4 < 131072) {
    out += (_v4 - 65536)
  } else {
    out += (196608 - _v4)
  }
  return (out >> 9)
}

to '_stepForNote' note octave {
  comment 'Return the step size required to generate the given note name in the given octave.
To make the pitches match other instruments, adjust tuningConstant so that an A
in octave zero generates a pitch as close as possible to 440Hz.'
  local 'tuningConstant' 329
  local 'freq' ('_baseFreqForNoteMulti' note)
  if (octave < 0) {
    repeat (absoluteValue octave) {
      freq = (freq / 2)
    }
  }
  repeat octave {
    freq = (freq * 2)
  }
  return ((freq * tuningConstant) >> 14)
}

to '_uppercaseNote' aString {
  local 'result' (newList (size aString))
  '[data:delete]' 'all' result
  for i (size aString) {
    local 'ch' ('[data:unicodeAt]' i aString)
    if (ch > 32) {
      if (and (97 <= ch) (ch <= 122)) {
        '[data:addLast]' (ch - 32) result
      } else {
        '[data:addLast]' ch result
      }
    }
  }
  return ('[data:unicodeString]' result)
}

to playNoteOnVoice note octave ms voice {
  comment 'Make sure _multiToneLoop is running. Set the step size for the given
voice to start playing the note, wait ms miliseconds, then set step size
to zero to to stop the note.'
  sendBroadcast '_multiToneLoop'
  if (1 == voice) {
    _v1Step = ('_stepForNote' note octave)
    waitMillis ms
    _v1Step = 0
  } (2 == voice) {
    _v2Step = ('_stepForNote' note octave)
    waitMillis ms
    _v2Step = 0
  } (3 == voice) {
    _v3Step = ('_stepForNote' note octave)
    waitMillis ms
    _v3Step = 0
  } (4 == voice) {
    _v4Step = ('_stepForNote' note octave)
    waitMillis ms
    _v4Step = 0
  }
}

to setMultitonePin pin {
  if (pin == '') {
    _multiToneInitialized = false
    return 0
  }
  _multiTonePin = pin
  _multiToneInitialized = true
}


module NeoPixel Output
author MicroBlocks
version 1 5 
description 'Control NeoPixel (WS2812) RGB LED strips and rings.
'
variables _np_pixels 

  spec ' ' 'neoPixelAttach' 'attach _ LED NeoPixel strip to pin _ : has white _' 'num auto bool' 10 '' false
  spec ' ' 'setNeoPixelColors10' 'set NeoPixels _ _ _ _ _ _ _ _ _ _' 'color color color color color color color color color color'
  spec ' ' 'clearNeoPixels' 'clear NeoPixels'
  spec ' ' 'neoPixelSetAllToColor' 'set all NeoPixels color _' 'color'
  spec ' ' 'setNeoPixelColor' 'set NeoPixel _ color _' 'num color' 1
  space
  spec 'r' 'colorFromRGB' 'color r _ g _ b _ (0-255)' 'num num num' 0 100 100
  spec 'r' 'randomColor' 'random color'
  space
  spec ' ' 'rotateNeoPixelsBy' 'rotate NeoPixels by _' 'auto' 1
  spec ' ' 'NeoPixel_brighten' 'brighten NeoPixel _ by _' 'num num' 1 10
  spec ' ' 'NeoPixel_brighten_all' 'brighten all NeoPixels by _' 'num' 10
  space
  spec ' ' '_NeoPixel_ensureInitialized' '_NeoPixel_ensureInitialized'
  spec ' ' '_NeoPixel_increaseRGB' '_NeoPixel_increaseRGB of _ by _' 'num num' 1 10
  spec ' ' '_NeoPixel_rotate' '_NeoPixel_rotate_left _' 'bool' true
  spec ' ' '_NeoPixel_update' '_NeoPixel_update'

to NeoPixel_brighten i delta {
  '_NeoPixel_increaseRGB' i delta
  '_NeoPixel_update'
}

to NeoPixel_brighten_all delta {
  for i (size _np_pixels) {
    '_NeoPixel_increaseRGB' i delta
  }
  '_NeoPixel_update'
}

to '_NeoPixel_ensureInitialized' {
  if (_np_pixels == 0) {if ((boardType) == 'M5Atom-Matrix') {
    neoPixelAttach 25 '' false
  } ((boardType) == 'D1-Mini') {
    comment 'D1 mini kit'
    neoPixelAttach 7 15 false
  } ((boardType) == 'Mbits') {
    neoPixelAttach 25 '' false
  } else {
    neoPixelAttach 10 '' false
  }}
}

to '_NeoPixel_increaseRGB' i delta {
  if (or (i < 1) (i > (size _np_pixels))) {return}
  local 'rgb' (at i _np_pixels)
  if (rgb != 0) {
    local 'r' ((rgb >> 16) & 255)
    local 'g' ((rgb >> 8) & 255)
    local 'b' (rgb & 255)
    r = (maximum 0 (minimum (r + delta) 255))
    g = (maximum 0 (minimum (g + delta) 255))
    b = (maximum 0 (minimum (b + delta) 255))
    atPut i _np_pixels (colorFromRGB r g b)
  }
}

to '_NeoPixel_rotate' left {
  '_NeoPixel_ensureInitialized'
  local 'length' (size _np_pixels)
  if left {
    local 'first' (at 1 _np_pixels)
    for i (length - 1) {
      atPut i _np_pixels (at (i + 1) _np_pixels)
    }
    atPut length _np_pixels first
  } else {
    local 'last' (at length _np_pixels)
    for i (length - 1) {
      atPut ((length - i) + 1) _np_pixels (at (length - i) _np_pixels)
    }
    atPut 1 _np_pixels last
  }
}

to '_NeoPixel_update' {
  '[display:neoPixelSend]' _np_pixels
  waitMicros 100
}

to clearNeoPixels {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels 0
  '_NeoPixel_update'
}

to colorFromRGB r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to neoPixelAttach number pinNumber optionalHasWhite {
  hasWhite = false
  if ((pushArgCount) > 2) {
    hasWhite = optionalHasWhite
  }
  if (or (_np_pixels == 0) (number != (size _np_pixels))) {
    _np_pixels = (newList number)
  }
  fillList _np_pixels 0
  '[display:neoPixelSetPin]' pinNumber hasWhite
}

to neoPixelSetAllToColor color {
  '_NeoPixel_ensureInitialized'
  fillList _np_pixels color
  '_NeoPixel_update'
}

to randomColor {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to rotateNeoPixelsBy n {
  '_NeoPixel_ensureInitialized'
  repeat (absoluteValue n) {
    '_NeoPixel_rotate' (n > 0)
  }
  '_NeoPixel_update'
}

to setNeoPixelColor i color {
  '_NeoPixel_ensureInitialized'
  if (and (1 <= i) (i <= (size _np_pixels))) {
    atPut i _np_pixels color
    '_NeoPixel_update'
  }
}

to setNeoPixelColors10 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 {
  '_NeoPixel_ensureInitialized'
  if ((size _np_pixels) >= 1) {
    atPut 1 _np_pixels c1
  }
  if ((size _np_pixels) >= 2) {
    atPut 2 _np_pixels c2
  }
  if ((size _np_pixels) >= 3) {
    atPut 3 _np_pixels c3
  }
  if ((size _np_pixels) >= 4) {
    atPut 4 _np_pixels c4
  }
  if ((size _np_pixels) >= 5) {
    atPut 5 _np_pixels c5
  }
  if ((size _np_pixels) >= 6) {
    atPut 6 _np_pixels c6
  }
  if ((size _np_pixels) >= 7) {
    atPut 7 _np_pixels c7
  }
  if ((size _np_pixels) >= 8) {
    atPut 8 _np_pixels c8
  }
  if ((size _np_pixels) >= 9) {
    atPut 9 _np_pixels c9
  }
  if ((size _np_pixels) >= 10) {
    atPut 10 _np_pixels c10
  }
  '_NeoPixel_update'
}


module Servo Output
author MicroBlocks
version 1 1 
tags servo motor angle rotation position 
description 'Control both positional (angle) and rotational servo motors.'
variables _servoPin _servoPulseWidth 

  spec ' ' 'setServoAngle' 'set servo _ to _ degrees (-90 to 90)' 'num num' 1 90
  spec ' ' 'setServoSpeed' 'set servo _ to speed _ (-100 to 100)' 'num num' 1 100
  spec ' ' 'stopServo' 'stop servo _' 'num' 1
  spec 'r' '_servoIndex' '_servoIndex _' 'num' 1
  spec ' ' '_servoPulse' '_servoPulse pin _ usecs _' 'num num' 1 1500
  spec ' ' '_servoUpdateLoop' '_servoUpdateLoop'

to '_servoIndex' which {
  if (_servoPin == 0) {
    _servoPin = ('[data:makeList]')
    _servoPulseWidth = ('[data:makeList]')
    sendBroadcast '_servoUpdateLoop'
  }
  local 'i' ('[data:find]' which _servoPin)
  if (i < 0) {
    comment 'Add new pin'
    '[data:addLast]' which _servoPin
    '[data:addLast]' '1500' _servoPulseWidth
    i = (size _servoPin)
  }
  return i
}

to '_servoPulse' pin usecs {
  if (usecs == 0) {
    comment 'Servo stopped; do nothing'
    return 0
  }
  usecs = (maximum 850 (minimum usecs 2150))
  comment 'Split wait into a long wait followed by a wait of <= 30 usecs for greater accuracy'
  local 'endTime' ((microsOp) + usecs)
  digitalWriteOp pin true
  waitMicros (usecs - 30)
  waitMicros (endTime - (microsOp))
  digitalWriteOp pin false
}

to '_servoUpdateLoop' {
  forever {
    if (_servoPin != 0) {
      comment 'If the _servoPin list is not 0, update the servos'
      for i (size _servoPin) {
        local 'pin' (at i _servoPin)
        local 'usecs' (at i _servoPulseWidth)
        if (and (pin >= 0) (usecs != 0)) {
          '_servoPulse' pin usecs
        }
      }
      waitMillis 15
    }
  }
}

to setServoAngle which degrees optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    degrees = (0 - degrees)
  }
  local 'pulseWidth' (1500 - (10 * degrees))
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to setServoSpeed which speed optionalReverse {
  local 'reversed' false
  if ((pushArgCount) > 2) {
    reversed = optionalReverse
  }
  if reversed {
    speed = (0 - speed)
  }
  local 'pulseWidth' (1500 - (10 * speed))
  if ((absoluteValue speed) < 2) {
    pulseWidth = 0
  }
  if ('[io:hasServo]') {
    '[io:setServo]' which pulseWidth
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth pulseWidth
  }
}

to stopServo which {
  if ('[io:hasServo]') {
    '[io:setServo]' which 0
  } else {
    atPut ('_servoIndex' which) _servoPulseWidth 0
  }
}


module 'Touch (MPR121)' Input
author MicroBlocks
version 1 7 
description 'Support for the MPR121 12-channel i2c touch sensor.'
variables _touch_state _touch_isTouched _touch_eventPending _touch_last_touched_pin _touch_last_released_pin 

  spec 'r' 'touch_isTouched' 'is pin _ touched?' 'menu.range:1-12' 1
  space
  spec 'r' 'touch_touch_event' 'pin touch event'
  spec 'r' 'touch_last_touched_pin' 'last touched pin'
  space
  spec 'r' 'touch_release_event' 'pin release event'
  spec 'r' 'touch_last_released_pin' 'last released pin'
  space
  spec 'r' 'touch_state_string' 'touch state string'
  space
  spec ' ' '_touch_init' '_touch_init'
  spec ' ' '_touch_update' '_touch_update'
  spec ' ' '_touch_setRegister' '_touch_setRegister _ to _' 'auto auto' 'hex register' 'hex value'

to '_touch_init' {
  if (isType _touch_isTouched 'list') {
    comment 'Already initialized.'
    return 0
  }
  _touch_isTouched = (newList 12 (booleanConstant false))
  _touch_eventPending = (newList 12 (booleanConstant false))
  _touch_last_touched_pin = -1
  _touch_last_released_pin = -1
  comment 'Soft reset -- sets all registers to defaults'
  '_touch_setRegister' '0x80' '0x63'
  comment 'Set filter parameters'
  '_touch_setRegister' '0x2B' '0x01'
  '_touch_setRegister' '0x2C' '0x01'
  '_touch_setRegister' '0x2D' '0x10'
  '_touch_setRegister' '0x2E' '0x20'
  '_touch_setRegister' '0x2F' '0x01'
  '_touch_setRegister' '0x30' '0x01'
  '_touch_setRegister' '0x31' '0x10'
  '_touch_setRegister' '0x32' '0x20'
  '_touch_setRegister' '0x33' '0x01'
  '_touch_setRegister' '0x34' '0x10'
  '_touch_setRegister' '0x35' '0xFF'
  comment 'Init debounce and config registers'
  '_touch_setRegister' '0x5B' '0x11'
  '_touch_setRegister' '0x5C' '0xFF'
  '_touch_setRegister' '0x5D' '0x30'
  comment 'Set touch/release thresholds'
  local 'touchThreshold' 40
  local 'releaseThreshold' 20
  for i 12 {
    local 'reg' ((hexToInt '40') + (2 * i))
    '_touch_setRegister' (reg - 1) touchThreshold
    '_touch_setRegister' reg releaseThreshold
  }
  comment 'Start tracking all 12 inputs (proximity detection disabled)'
  '_touch_setRegister' '0x5E' '0xCC'
}

to '_touch_setRegister' reg value {
  if (isType reg 'string') {reg = (hexToInt reg)}
  if (isType value 'string') {value = (hexToInt value)}
  i2cSet 90 reg value
}

to '_touch_update' {
  '_touch_init'
  _touch_state = (((i2cGet 90 1) << 8) | (i2cGet 90 0))
  if (_touch_state < 0) {
    comment 'i2c read operation failed'
    _touch_state = 0
  }
  for i 12 {
    local 'isTouchedNow' ((_touch_state & (1 << (i - 1))) != 0)
    if ((at i _touch_isTouched) != isTouchedNow) {
      atPut i _touch_isTouched isTouchedNow
      atPut i _touch_eventPending (booleanConstant true)
    }
  }
}

to touch_isTouched pin {
  if (or (pin < 1) (pin > 12)) {return (booleanConstant false)}
  '_touch_update'
  return ((_touch_state & (1 << (pin - 1))) != 0)
}

to touch_last_released_pin {
  comment 'Return the pin that triggered the last release event.'
  '_touch_init'
  return _touch_last_released_pin
}

to touch_last_touched_pin {
  comment 'Return the pin that triggered the last touch event.'
  '_touch_init'
  return _touch_last_touched_pin
}

to touch_release_event {
  '_touch_update'
  for i 12 {
    if (and (at i _touch_eventPending) ((_touch_state & (1 << (i - 1))) == 0)) {
      atPut i _touch_eventPending (booleanConstant false)
      _touch_last_released_pin = i
      return (booleanConstant true)
    }
  }
  _touch_last_released_pin = -1
  return (booleanConstant false)
}

to touch_state_string {
  '_touch_update'
  local 'pin states' ('[data:makeList]')
  for i 12 {
    if ((_touch_state & (1 << (i - 1))) != 0) {
      '[data:addLast]' '1' (v 'pin states')
    } else {
      '[data:addLast]' '0' (v 'pin states')
    }
  }
  return ('[data:joinStrings]' (v 'pin states'))
}

to touch_touch_event {
  '_touch_update'
  for i 12 {
    if (and (at i _touch_eventPending) ((_touch_state & (1 << (i - 1))) != 0)) {
      atPut i _touch_eventPending (booleanConstant false)
      _touch_last_touched_pin = i
      return (booleanConstant true)
    }
  }
  _touch_last_touched_pin = -1
  return (booleanConstant false)
}


module 'timeAveragedLevel.ubp'
author unknown
version 1 0 
description ''
variables samples average timeAverages timeToFinish 

  spec 'r' '_compute time average' '_compute time average _ _ _' 'auto auto auto' 1 64 0
  spec 'r' 'timeAveragedLevel' 'time average of pin _ with time samples _' 'auto auto' 1 64

to '_compute time average' pin timeSample timeAverage {
  samples = 0
  average = 0
  timeToFinish = ((millisOp) + timeSample)
  repeatUntil ((millisOp) >= timeToFinish) {
    samples += 1
    average += (absoluteValue ((analogReadOp pin) - timeAverage))
  }
  return (average / (maximum samples 1))
}

to timeAveragedLevel pin timeSample {
  if ((size timeAverages) == 0) {timeAverages = (newList 32 0)}
  average = ('_compute time average' pin timeSample (at pin timeAverages))
  if ((at pin timeAverages) == 0) {
    atPut pin timeAverages average
    average = 0
  }
  return average
}

